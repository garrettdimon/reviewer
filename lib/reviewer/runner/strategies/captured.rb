# frozen_string_literal: true

require 'ruby-progressbar'

module Reviewer
  class Runner
    module Strategies
      # Execution strategy for a runner to run a command quietly by capturing the output and only
      #   displaying it if there's a failure that justifies it
      # @attr_reader runner [Runner] the instance of the runner that will be executed with this strategy
      # @attr_reader start_time [Time] the start time for the strategy_for timing purposes
      class Captured
        # 256-color ANSI codes for progress bar styling (not in AnsiStyles' 16-color palette)
        PROGRESS_GRAY      = "\e[38;5;245m"
        PROGRESS_DARK_GRAY = "\e[38;5;240m"
        ANSI_RESET         = "\e[0m"
        ERASE_LINE         = "\r\e[2K"

        attr_reader :runner, :start_time

        # Create an instance of the captured strategy for a command runner so that any output is
        #    fully suppressed so as to not create too much noise when running multiple commands.
        # @param runner [Runner] the instance of the runner to apply the strategy to
        #
        # @return [self]
        def initialize(runner)
          @runner = runner
          @start_time = Time.now
        end

        # The prepare command strategy when running a command and capturing the results
        #
        # @return [void]
        def prepare
          command = runner.prepare_command

          display_progress(command) { runner.shell.capture_prep(command) }

          # Erase the prep progress bar â€” the run step will show its own
          stream.print(ERASE_LINE) if style_enabled? && runner.streaming?

          # Running the prepare command, so make sure the timestamp is updated
          runner.update_last_prepared_at
        end

        # The run command strategy when running a command and capturing the results
        #
        # @return [void]
        def run
          command = runner.command

          display_progress(command) { runner.shell.capture_main(command) }

          # Skip output for non-streaming modes - results are formatted at the end
          return unless runner.streaming?

          # Missing tools are handled by the Runner (shows "Skipped (not installed)")
          return if runner.shell.result.executable_not_found?

          # If it's successful, show that it was a success and how long it took to run, otherwise,
          # it wasn't successful and we got some explaining to do...
          runner.success? ? show_timing_result : show_command_output
        end

        private

        # Displays the progress of the current command since the output is captured/suppressed.
        #   Helps people know that the sub-command is running within expectations.
        # @param command [String] the precise command string generated by Reviewer. Serves as the
        #   key for looking up the command's history.
        # @param block [Block] the runner for the command that's being timed and having its
        #   progress updated and printed
        #
        # @return [void]
        def display_progress(command)
          average_time = runner.tool.average_time(command)
          start_time = Time.now
          thread = Thread.new { yield }

          # Skip progress output for non-streaming modes
          return thread.join unless runner.streaming?

          print_progress(thread, start_time, average_time)
        end

        def print_progress(thread, start_time, average_time)
          bar = create_progress_bar(average_time)

          while thread.alive?
            update_progress(bar, start_time, average_time)
            sleep 0.1
          end

          thread.join

          # Erase the progress bar line if the executable wasn't found
          if runner.shell.result.executable_not_found?
            stream.print(ERASE_LINE) if style_enabled?
            return
          end

          finish_progress_bar(bar, average_time.positive?)
        end

        def finish_progress_bar(bar, timed)
          if timed
            bar.format = style_enabled? ? "#{PROGRESS_GRAY}%b#{PROGRESS_DARK_GRAY}%i %p%%#{ANSI_RESET}" : '%b%i %p%%'
            bar.finish
          else
            bar.stop
          end
        end

        def create_progress_bar(average_time)
          shared = {
            output: stream,
            title: '',
            progress_mark: "\u2501",
            remainder_mark: "\u2500"
          }

          if average_time.positive?
            eta = average_time >= 3 ? ' %e' : ''
            format = style_enabled? ? "#{PROGRESS_GRAY}%b#{PROGRESS_DARK_GRAY}%i %p%%#{eta}#{ANSI_RESET}" : "%b%i %p%%#{eta}"
            ProgressBar.create(**shared, total: 100, format: format)
          else
            format = style_enabled? ? "#{PROGRESS_GRAY}%B#{ANSI_RESET}" : '%B'
            ProgressBar.create(**shared, total: nil, format: format)
          end
        end

        def update_progress(bar, start_time, average_time)
          if average_time.positive?
            elapsed = Time.now - start_time
            percent = [(elapsed / average_time * 100).round, 99].min
            bar.progress = percent if percent > bar.progress
          else
            bar.increment
          end
        end

        # The output stream from the runner's printer
        # @return [IO]
        def stream = runner.output.printer.stream

        # Whether ANSI styling is enabled on the output stream
        # @return [Boolean]
        def style_enabled? = runner.output.printer.style_enabled?

        # Determines if stdout or stderr captured any useful output that can be displayed in order
        #   to more rapidly display output when a command fails. As long as both aren't nil or
        #   otherwise 'blank' strings, then that's enough.
        #
        # @return [Boolean] true if either stdout or stderr contain printable content
        def usable_output_captured?
          [runner.stdout, runner.stderr].reject { |value| value.to_s.strip.empty? }.any?
        end

        # Prints "Success" and the resulting timing details before moving on to the next tool
        #
        # @return [void]
        def show_timing_result
          runner.record_timing
          runner.formatter.success(runner.timer)
        end

        # Prints "Failure" and the resulting exit status. Shows the precise command that led to the
        # failure for easier copy and paste or making it easier to see any incorrect syntax or
        # options that could be corrected.
        #
        # @return [void]
        def show_command_output
          # If there's a failure, clear the successful command output to focus on the issues
          runner.output.clear

          # Show the exit status and failed command
          runner.formatter.failure("Exit Status #{runner.exit_status}", command: runner.command)

          # If it can't be rerun, then don't try
          usable_output_captured? ? show_captured_output : rerun_via_passthrough
        end

        # If the command sent output to stdout/stderr as most will, simply display what was captured
        #
        # @return [void]
        def show_captured_output
          show_captured_stdout
          show_captured_stderr
        end

        # If there's a useful stdout value, display it with a divider to visually separate it.
        #
        # @return [void]
        def show_captured_stdout
          stdout = runner.stdout.to_s
          return if stdout.empty?

          runner.output.divider
          runner.output.newline
          runner.output.unfiltered(stdout)
        end

        # If there's a useful stderr value, display it with a divider to visually separate it.
        #
        # @return [void]
        def show_captured_stderr
          stderr = runner.stderr.to_s
          return if stderr.empty?

          scrubbed_stderr = Output.scrub(stderr)

          runner.output.divider
          runner.output.newline
          runner.formatter.guidance('Runtime Errors:', scrubbed_stderr)
        end

        # If for some reason, the command didn't send anything to stdout/stderr, the only option to
        # show results is to rerun it via the passthrough strategy
        #
        # @return [void]
        def rerun_via_passthrough
          return unless runner.rerunnable?

          runner.strategy = Strategies::Passthrough

          runner.output.divider
          runner.run
        end
      end
    end
  end
end
